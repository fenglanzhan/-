> 执行上下文，也称 **`execution context`**  或 **`内存作用域`**，在代码执行时创建；
>
> 作用域，也称**`scope`**或**`Lexical Environments`**词法环境，代码书写时确定。

## 执行上下文

作用：用于跟踪代码的运行情况

通俗的理解：一个函数根据运行情况不同，可以产生0个至多个执行上下文。

创建过程：

1. 代码块：一段代码块对应一个执行上下文，全局或者封装成函数的代码都是代码块
2. 当程序运行，进入到某段代码块时，创建新的执行上下文，放入stack中，当程序运行到这段代码块结尾后，对应的执行上下文被弹出stack
3. 当程序在某段代码中运行到某个点需要转到另一个代码块（调用了另一个函数），那么当前的可执行上下文状态会被置为挂起，然后生成一个新的可执行上下文放入stack顶部
4. stack顶部的可执行上下文称为`running execution context`。当顶部的可执行上下文被弹出，上一个挂起的可执行上下文继续执行。

内部属性：

1. [[code evaluation]]：当前代码块执行的状态；preform（）、suspend（挂起）、resume（恢复，继续）
2. [[Function]]：若当前执行上下文对应的是函数，name此属性保存该函数对象；若是全局环境（script或者module），为null
3. <u>[[Real]]：</u>暂时不知道是什么鬼



## 作用域

作用域内部信息：

1. `Environment record`：该作用域内部的变量信息（包括常量，函数，参数变量等）和<u>代码结构信息</u>
2. `__outer__`：指向父级作用域的引用；全局作用域中 该属性指向`null`

生成作用域的情况

1. 函数
2. catch语句：但是该作用域下保存catch语句中的参数err与块级作用域中的变量（详见3）
3. 语句块{}：只绑定块级变量、常量等，即let、const声明的属于块级作用域

## 从变量查找看作用域和执行上下文

> 函数执行时，创建的上下文对象除了保存代码执行情况，还会保存当前作用域。

变量查找时，首先从当前执行上下文中找到保存的作用域（对象），然后通过作用域链向上查找变量。

## this

this的值时通过当前执行上下文保存的作用域（对象）来获取的。